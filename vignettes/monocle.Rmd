---
title: "Building trajectories with Monocle 3"
output: html_document
---

In this vignette we will demonstrate how to construct cell trajectories with 
Monocle 3 using single-cell ATAC-seq data. Please see the
Monocle 3 [website](https://cole-trapnell-lab.github.io/monocle3/) for 
information about installing Monocle 3.

To facilitate conversion between the Seurat (used by Signac) and CellDataSet
(used by Monocle 3) formats, we will use a conversion function in the 
[SeuratWrappers](https://github.com/satijalab/seurat-wrappers) package available
on GitHub.

## Data loading

We will use a single-cell ATAC-seq dataset containing human CD34+ hematopoietic
stem and progenitor cells published by
[Satpathy and Granja et al. (2019, Nature Biotechnology)](https://doi.org/10.1038/s41587-019-0206-z).

The processed datasets are available on NCBI GEO here:
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE129785

First we will load their dataset and perform some standard preprocessing using
Signac.

```{r message=FALSE, warning=FALSE}
library(Signac)
library(Seurat)
library(SeuratWrappers)
library(monocle3)
library(Matrix)
library(ggplot2)
library(patchwork)
set.seed(1234)
```

```{r}
filepath <- "~/data/satpathy19/GSE129785/GSE129785_scATAC-Hematopoiesis-CD34"

peaks <- read.table(paste0(filepath, ".peaks.txt.gz"), header = TRUE)
cells <- read.table(paste0(filepath, ".cell_barcodes.txt.gz"), header = TRUE, stringsAsFactors = FALSE)
rownames(cells) <- make.unique(cells$Barcodes)

mtx <- readMM(file = paste0(filepath, ".mtx"))
mtx <- as(object = mtx, Class = "dgCMatrix")
colnames(mtx) <- rownames(cells)
rownames(mtx) <- peaks$Feature
```

```{r message=FALSE, warning=FALSE}
bone <- CreateSignacObject(
  counts = mtx,
  min.cells = 5,
  meta.data = cells,
  fragments = "~/data/satpathy19/GSE129785/GSM3722029_CD34_Progenitors_Rep1_fragments.tsv.gz",
  sep = c("_", "_"),
  genome = "hg19"
)

# The dataset contains multiple cell types
# We can subset to include just one replicate of CD34+ progenitor cells
bone <- bone[, bone$Group_Barcode == "CD34_Progenitors_Rep1"]
bone[["ATAC"]]
```

Next we can add gene annotations for the hg19 genome to the object. This will 
be useful for computing quality control metrics (TSS enrichment score) and 
plotting.

```{r message=FALSE, warning=FALSE}
library(EnsDb.Hsapiens.v75)

gene.ranges <- genes(EnsDb.Hsapiens.v75)
gene.ranges <- gene.ranges[gene.ranges$gene_biotype == 'protein_coding', ]
seqlevelsStyle(gene.ranges) <- 'UCSC'
genome(gene.ranges) <- "hg19"
gene.ranges <- keepStandardChromosomes(gene.ranges, pruning.mode = 'coarse')
Annotation(bone) <- gene.ranges
```

## Quality control

We'll compute TSS enrichment, nucleosome signal score, and the percentage of 
counts in genomic blacklist regions for each cell, and use these metrics to 
help remove low quality cells from the datasets.

```{r message=FALSE, warning=FALSE}
bone <- TSSEnrichment(bone)
bone <- NucleosomeSignal(bone)
bone$blacklist_fraction <- FractionCountsInRegion(bone, regions = blacklist_hg19)
```

```{r fig.height=6, fig.width=8, message=FALSE, warning=FALSE}
VlnPlot(
  object = bone,
  features = c("nCount_ATAC", "TSS.enrichment", "nucleosome_signal", "blacklist_fraction"),
  pt.size = 0.1,
  ncol = 4
)
```

```{r}
bone <- bone[, (bone$nCount_ATAC < 50000) &
               (bone$TSS.enrichment > 2) & 
               (bone$nucleosome_signal > 1) &
               (bone$nucleosome_signal < 5)]
```

## Dataset preprocessing

Next we can run a standard scATAC-seq analysis pipeline using Signac to perform
dimension reduction, clustering, and cell type annotation.

```{r}
bone <- FindTopFeatures(bone, min.cells = 10)
bone <- RunTFIDF(bone)
bone <- RunSVD(bone, n = 100, reduction.name = "LSI", reduction.key = "LSI_")
DepthCor(bone, reduction = 'LSI')
```

```{r message=FALSE, warning=FALSE}
bone <- RunUMAP(
  bone,
  reduction = "LSI",
  dims = 2:60,
  reduction.name = "UMAP"
)
```

```{r message=FALSE, warning=FALSE}
bone <- FindNeighbors(bone, dims = 2:60, reduction = "LSI")
bone <- FindClusters(bone, resolution = 0.5, algorithm = 3)
```

```{r}
DimPlot(bone, label = TRUE) + NoLegend()
```

## Integration with scRNA-seq

To aid in the annotation of cell type, we'll transfer gene expression values for
each cell in the scATAC-seq dataset using an existing scRNA-seq dataset from 
CD34+ human bone marrow cells, published by 
[Pellin and Loperfido et al. (2019)](https://www.nature.com/articles/s41467-019-10291-0).

<details>
 <summary>View scRNA-seq processing code</summary>

```{r, eval = FALSE}
hsc.counts <- read.table("~/data/pellin19/GSM3305359_HSC.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)
mpp.counts <- read.table("~/data/pellin19/GSM3305360_MPP.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)
mpl.counts <- read.table("~/data/pellin19/GSM3305361_MLP.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)
pre_bnk.counts <- read.table("~/data/pellin19/GSM3305362_PreBNK.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)
mep.counts <- read.table("~/data/pellin19/GSM3305363_MEP.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)
cmp.counts <- read.table("~/data/pellin19/GSM3305364_CMP.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)
gmp.counts <- read.table("~/data/pellin19/GSM3305365_GMP.raw_counts.tsv.gz", sep = "\t", header = TRUE, row.names = 1)

hsc <- CreateSeuratObject(counts = hsc.counts[2:nrow(hsc.counts), ], project = "HSC")
mpp <- CreateSeuratObject(counts = mpp.counts[2:nrow(mpp.counts), ], project = "MPP")
mpl <- CreateSeuratObject(counts = mpl.counts[2:nrow(mpl.counts), ], project = "MPL")
preBNK <- CreateSeuratObject(counts = pre_bnk.counts[2:nrow(pre_bnk.counts), ], project = "PreBNK")
cmp <- CreateSeuratObject(counts = cmp.counts[2:nrow(cmp.counts), ], project = "CMP")
gmp <- CreateSeuratObject(counts = gmp.counts[2:nrow(gmp.counts), ], project = "GMP")

bone.rna <- merge(hsc, list(mpp, mpl, preBNK, cmp, gmp))

bone.rna <- NormalizeData(bone.rna)
bone.rna <- FindVariableFeatures(bone.rna)
bone.rna <- ScaleData(bone.rna)
bone.rna <- RunPCA(bone.rna)
bone.rna <- RunUMAP(bone.rna, dims = 1:30, reduction = "pca")
saveRDS(bone.rna, "../vignette_data/cd34_rna.rds")
```

</details>

```{r}
bone.rna <- readRDS("../vignette_data/cd34_rna.rds")
DimPlot(bone.rna, label = TRUE) + NoLegend()
```

Add a gene activity assay to the scATAC-seq dataset.

```{r message=FALSE, warning=FALSE, cache=TRUE}
# Extend coordinates upstream to include the promoter
genebodyandpromoter.coords <- Extend(x = gene.ranges, upstream = 2000, downstream = 0)

# create a gene by cell matrix
gene.activities <- FeatureMatrix(
  fragments = Fragments(bone),
  features = genebodyandpromoter.coords,
  cells = colnames(bone)
)

# convert rownames from chromsomal coordinates into gene names
gene.key <- genebodyandpromoter.coords$gene_name
names(gene.key) <- GRangesToString(grange = genebodyandpromoter.coords)
rownames(gene.activities) <- gene.key[rownames(gene.activities)]
```

```{r message=FALSE, warning=FALSE}
# add the gene activity matrix to the Seurat object as a new assay, and normalize it
bone[['RNA']] <- CreateAssayObject(counts = gene.activities)
bone <- NormalizeData(
  object = bone,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(bone$nCount_RNA)
)
```

```{r message=FALSE, warning=FALSE}
DefaultAssay(bone) <- "RNA"

# find transfer anchors
transfer.anchors <- FindTransferAnchors(
  reference = bone.rna,
  query = bone,
  reduction = 'cca'
)

# predict gene expression
predicted.exp <- TransferData(
  anchorset = transfer.anchors,
  refdata = GetAssayData(bone.rna, slot = "data"),
  weight.reduction = bone[['LSI']],
  dims = 2:60
)

# replace the gene activity assay with the predicted gene expression values
bone[["RNA"]] <- predicted.exp
```

<!-- spib = pdc -->
<!-- gata1 = mk/erythroid -->
<!-- gata2 = basophil/eosinophil -->
<!-- ebf1 = b cell -->
<!-- bcl11a = pdc -->
<!-- tcf4   = pdc -->
<!-- cebpb  = granulocyte / macrophage progenitor -->
<!-- hoxa9 = hsc -->
<!-- bst2  = hsc -->
<!-- klf4 = dc -->
<!-- spib = dc -->
<!-- mme = lymphoid -->
<!-- csf2rb = erythroid -->
<!-- csf3r = granulocytes -->
<!-- jun  = dc -->
<!-- rara, cebp = neutrophil -->

We can inspect the predicted expression patterns for a few different genes to 
help assign cell type labels to the cells, and determine which cells belong to 
the different lineages.

```{r fig.height=8, fig.width=8, message=FALSE, warning=FALSE}
DefaultAssay(bone) <- "RNA"

FeaturePlot(
  object = bone,
  features = c("BST2", "BCL11A", "SPIB", "TCF4",
               "CEBPB", "GATA1", "CD14", "GATA2",
               "KLF4", "EBF1", "LTB", "HCST"),
  pt.size = 0.1,
  min.cutoff = 'q5',
  max.cutoff = 'q95'
) & NoLegend()
```

Based on these makers we can roughly assign clusters to cell states. These
classifications have been guided by the following papers:

* [Zheng et al. 2019](https://doi.org/10.15252/msb.20178041)
* [Pellin and Loperfido et al. 2019](https://www.nature.com/articles/s41467-019-10291-0)

```{r}
# LMPP is lymphoid-primed multipotent progenitor
# HSC is hematopoietic stem cell
# Neu/Mono is neutrophil and monocyte
# Ba/Eo is basophil and eosinophil

new.cluster.ids <- c(
  "LMPP",        # 0
  "LMPP",        # 1
  "HSC",         # 2
  "Neu/Mono",    # 3
  "Lymphoid",    # 4
  "Erythroid",   # 5
  "Neu/Mono",    # 6
  "Lymphoid",    # 7
  "Ba/Eo",       # 8
  "Neu/Mono"     # 9
)
names(new.cluster.ids) <- levels(bone)
bone$celltype <- new.cluster.ids[bone$seurat_clusters]
DimPlot(bone, group.by = "celltype", label = TRUE)
```

Next we can subset the different lineages and create a trajectory for each
lineage. Another way to build the trajectories is to use the whole dataset and 
build separate pseudotime trajectories for the different cell partitions found
by Monocle 3.

```{r}
DefaultAssay(bone) <- "ATAC"
Idents(bone) <- "celltype"

erythroid <- bone[,  bone$celltype %in% c("HSC", "Erythroid", "Ba/Eo")]
lymphoid <- bone[, bone$celltype %in% c("HSC", "Lymphoid", "Neu/Mono", "LMPP")]
```

## Building trajectories with Monocle 3

We can convert the Seurat object to a CellDataSet object using the
`as.cell_data_set()` function from [SeuratWrappers](https://github.com/satijalab/seurat-wrappers)
and build the trajectories using Monocle 3. We'll do this separately for 
erythroid and lymphoid lineages, but you could explore other strategies building
a trajectory for all lineages together.

```{r message=FALSE, warning=FALSE}
erythroid.cds <- as.cell_data_set(erythroid)
erythroid.cds <- cluster_cells(cds = erythroid.cds, reduction_method = "UMAP")
erythroid.cds <- learn_graph(erythroid.cds, use_partition = TRUE)

lymphoid.cds <- as.cell_data_set(lymphoid)
lymphoid.cds <- cluster_cells(cds = lymphoid.cds, reduction_method = "UMAP", resolution = 0.0001)
lymphoid.cds <- learn_graph(lymphoid.cds, use_partition = TRUE)
```

To compute pseudotime estimates for each trajectory we need to decide what the
start of each trajectory is. In our case, we know that the hematopoietic stem
cells are the progenitors of other cell types in the trajectory, so we can set
these cells as the root of the trajectory. Monocle 3 includes an interactive 
function to select cells as the root nodes in the graph. This function will be 
launched if calling `order_cells()` without specifying the `root_cells` parameter.
Here we've pre-selected some cells as the root, and saved these to a file for 
reproducibility.

```{r}
# load the pre-selected HSCs
hsc <- readLines("../vignette_data/hsc_cells.txt")
```

```{r message=FALSE, warning=FALSE}
# order cells
erythroid.cds <- order_cells(erythroid.cds, reduction_method = "UMAP", root_cells = hsc)
lymphoid.cds <- order_cells(lymphoid.cds, reduction_method = "UMAP", root_cells = hsc)

# plot trajectories colored by pseudotime
plot_cells(
  cds = erythroid.cds,
  color_cells_by = "pseudotime",
  show_trajectory_graph = TRUE
)

plot_cells(
  cds = lymphoid.cds,
  color_cells_by = "pseudotime",
  show_trajectory_graph = TRUE
)
```

Extract the pseudotime values and add to the Seurat object

```{r}
bone <- AddMetaData(
  object = bone,
  metadata = erythroid.cds@principal_graph_aux@listData$UMAP$pseudotime,
  col.name = "Erythroid"
)

bone <- AddMetaData(
  object = bone,
  metadata = lymphoid.cds@principal_graph_aux@listData$UMAP$pseudotime,
  col.name = "Lymphoid"
)
```

```{r fig.height=6, fig.width=8, message=FALSE, warning=FALSE}
FeaturePlot(bone, c("Erythroid", "Lymphoid"), pt.size = 0.1) & scale_color_viridis_c()
```

```{r, include=FALSE}
saveRDS(object = bone, file = "../vignette_data/cd34.rds")
```

## Acknowledgements

Thanks to the developers of Monocle 3, especially Cole Trapnell, Hannah Pliner,
and members of the [Trapnell lab](https://cole-trapnell-lab.github.io/). If you
use Monocle please cite the
[Monocle papers](https://cole-trapnell-lab.github.io/monocle3/docs/citations/).
