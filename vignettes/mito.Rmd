---
title: "Joint single-cell mitochondrial DNA genotyping and DNA accessibility analysis"
author: Caleb Lareau and Tim Stuart
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    self_contained: True
---

```{r packages, cache=FALSE, message=FALSE, warning = FALSE, echo = TRUE}
library(Signac)
library(Seurat)
library(ggplot2)
library(patchwork)
library(EnsDb.Hsapiens.v75)
```

Here, we take a look at two different datasets containing both DNA accessibility
measurements and mitochondrial mutation data in the same cells. One was sampled
from a patient with a colorectal cancer (CRC) tumor, and the other is from a TF1
cell line. This data was produced by Lareau and Ludwig et al. (2020), and you
can read the original paper here: XXX

DNA accessibility data for the CRC dataset is available on NCBI GEO here: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE148509

Mitochondrial variant data for the CRC dataset is available on XXX here:

Raw sequencing data and DNA accessibility processed files for the TF1 dataset
are available on NCBI GEO here:
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE148509

# Colorectal cancer dataset

## Loading the DNA accessibility data

First we load the scATAC-seq data and create a Seurat object following the 
standard workflow for scATAC-seq data.
  
```{r importData, message=FALSE, warning = FALSE}
# load counts and metadata from cellranger-atac
counts <- Read10X_h5(filename = "~/data/mito/crc/filtered_peak_bc_matrix.h5")
metadata <- read.csv(
  file = "~/data/mito/crc/singlecell.csv",
  header = TRUE,
  row.names = 1
)

# load gene annotations from Ensembl
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)

# change to UCSC style since the data was mapped to hg19
seqlevelsStyle(annotations) <- 'UCSC'
genome(annotations) <- "hg19"

# create object
crc <- CreateSignacObject(
  counts = counts,
  sep = c(":", "-"),
  assay = 'peaks',
  annotation = annotations,
  min.cells = 10,
  genome = "hg19",
  fragments = '~/data/mito/crc/fragments.tsv.gz',
  meta.data = metadata
)

crc[["peaks"]]
```

## Quality control

We can compute the standard quality control metrics for scATAC-seq and filter
out low-quality cells based on these metrics.

```{r message=FALSE, warning=FALSE}
# Augment QC metrics that were computed by cellranger-atac
crc$pct_reads_in_peaks <- crc$peak_region_fragments / crc$passed_filters * 100
crc$pct_reads_in_DNase <- crc$DNase_sensitive_region_fragments / crc$passed_filters * 100
crc$blacklist_ratio <- crc$blacklist_region_fragments / crc$peak_region_fragments

# compute TSS enrichment score and nucleosome banding pattern
crc <- TSSEnrichment(crc)
crc <- NucleosomeSignal(crc)
```

```{r fig.width=8, fig.height = 8, message=FALSE, warning=FALSE}
# visualize QC metrics for each cell
VlnPlot(crc, c("TSS.enrichment", "nCount_peaks", "nucleosome_signal", "pct_reads_in_peaks", "pct_reads_in_DNase", "blacklist_ratio"), pt.size = 0, ncol = 3)
```

```{r}
crc$tss.high <- ifelse(crc$TSS.enrichment > 3, "High", "Low")
TSSPlot(crc, group.by = "tss.high")
```

```{r}
# remove low-quality cells
crc <- subset(
  x = crc,
  subset = nCount_peaks > 1000 &
    nCount_peaks < 50000 &
    pct_reads_in_DNase > 40 &
    blacklist_ratio < 0.05 &
    TSS.enrichment > 3 & 
    nucleosome_signal < 10
)
crc
```

## Loading the mitochondrial variant data

Next we can load the mitochondrial DNA variant data for these cells that was 
quantified using [mGATK](https://github.com/caleblareau/mgatk). The `ReadMGATK()`
function in Signac allows the output from mGATK to be read directly into R in a
convenient format for downstream analysis with Signac. Here we load the data
and add it to the Seurat object as a new assay.

```{r process_mito, cache=TRUE, message=FALSE, warning = FALSE, echo = TRUE}
# load mGATK output
mito.data <- ReadMGATK(dir = "~/data/mito/crc/mgatk_inputs/")

# create an assay
mito <- CreateAssayObject(counts = mito.data$counts)

# Subset to cell present in the scATAC-seq assat
mito <- subset(mito, cells = colnames(crc))

# add assay and metadata to the seurat object
crc[["mito"]] <- mito
crc <- AddMetaData(crc, metadata = mito.data$depth, col.name = "mtDNA_depth")
```

We can look at the mitochondrial sequencing depth for each cell, and further
subset the cells based on mitochondrial sequencing depth.

```{r message=FALSE, warning=FALSE}
VlnPlot(crc, "mtDNA_depth", pt.size = 0.1) + scale_y_log10()
```

```{r}
# filter cells based on mitochondrial depth
crc <- subset(crc, mtDNA_depth >= 10)
crc
```

## Dimension reduction and clustering

Next we can run a standard dimension reduction and clustering workflow using the
scATAC-seq data to identify cell clusters.

```{r message=FALSE, warning=FALSE}
crc <- RunTFIDF(crc)
crc <- FindTopFeatures(crc, min.cutoff = 10)
crc <- RunSVD(crc)
crc <- RunUMAP(crc, reduction = "lsi", dims = 2:50)
crc <- FindNeighbors(crc, reduction = "lsi", dims = 2:50)
crc <- FindClusters(crc, resolution = 0.5, algorithm = 3)
```

```{r message=FALSE, warning=FALSE}
DimPlot(crc, label = TRUE) + NoLegend()
```

## Generate gene scores

To help interpret these clusters of cells, and assign a cell type label, we'll
estimate gene activities by summing the DNA accessibility in the gene body and
promoter region.

```{r setup_gene_activity, cache=FALSE, message=FALSE, warning = FALSE, echo = TRUE}
# compute gene accessibility
gene.activities <- GeneActivity(crc)

# add to the Seurat object as a new assay
crc[['RNA']] <- CreateAssayObject(counts = gene.activities)

crc <- NormalizeData(
  object = crc,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(crc$nCount_RNA)
)
```

## Visualize interesting gene activity scores

- EPCAM is a marker for epithelial cells
- TREM1 is a meyloid marker
- PTPRC = CD45 = Pan immune cell marker
- IL1RL1 are basophil markers
- GATA3 is a Treg marker
- KIT is a Treg marker

```{r viz_gene_activitites, message=FALSE, warning = FALSE, fig.width=8, fig.height=8}
DefaultAssay(crc) <- 'RNA'

FeaturePlot(
  object = crc,
  features = c('TREM1', 'EPCAM', "PTPRC", "IL1RL1","GATA3", "KIT"),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 2
)
```

Using these gene score values, we can assign cluster identities: 

```{r}
crc <- RenameIdents(
  object = crc,
  '0' = 'Epithelial',
  '1' = 'Epithelial',
  '2' = 'Basophil',
  '3' = 'Myeloid_1',
  '4' = 'Myeloid_2',
  '5' = 'Treg'
)
```

One of the myeloid clusters has a lower percentage of fragments in peaks, as
well as a lower overall mitochondrial sequencing depth and a different
nucleosome banding pattern.

```{r cell_filtering_recap, message=FALSE, warning = FALSE}
p1 <- FeatureScatter(crc, "mtDNA_depth", "pct_reads_in_peaks") + ggtitle("") + scale_x_log10()
p2 <- FeatureScatter(crc, "mtDNA_depth", "nucleosome_signal") + ggtitle("") + scale_x_log10()

p1 + p2 + plot_layout(guides = 'collect')
```

We can see that most of the low FRIP cells were the `myeloid 1` cluster. This is
some sort of intra-tumor granulocyte that has relatively poor accessible
chromatin enrichment.

## Find informative mtDNA variants

Next we can identify sites in the mitochondrial genome that vary across cells, 
and cluster the cells into clonotypes based on the frequency of these variants
in the cells.

```{r call_variants, cache=TRUE, message=FALSE, warning = FALSE, echo = TRUE}
variable.sites <- IdentifyVariants(crc, assay = "mito", refallele = mito.data$refallele)
VariantPlot(variants = variable.sites)
```

The plot above clearly shows a group of variants with a higher VMR and strand
concordance. Based on these thresholds, we can filter out a set of informative
mitochondrial variants that differ across the cells.

```{r look_at_variants, message=FALSE, warning = FALSE}
# Establish a filtered data frame of variants based on this processing
high.conf <- subset(
  variable.sites, subset = n_cells_conf_detected >= 5 &
    strand_correlation >= 0.65 &
    vmr > 0.01
)

high.conf[,c(1,2,3,5)]
```

A few things stand out. First, 10 out of the 12 variants occur at less than 1% 
allele frequency in the population. However, 16147C>T is present at about 62%.
We'll see that this is a clonal variant marking the epithelial cells.
Additionally, all of the called variants are transitions (A - G or C - T) rather
than transversion mutations (A - T or C - G). This fits what we know about how
these mutations arise in the genome (TODO add link/citation).

## Compute the variant allele frequency for each cell

We currently have information for each strand stored in the mito assay to allow
strand concordance to be assessed. Now that we have our set of high-confidence
informative variants, we can create a new assay containing strand-collapsed
allele frequency counts for each cell for these variants using the `AlleleFreq()`
function.

```{r}
crc <- AlleleFreq(
  object = crc,
  variants = high.conf$variant,
  assay = "mito"
)
crc[["alleles"]]
```

## Visualize the variants

Now that the allele frequencies are stored as an additional assay, we can use
the standard functions in Seurat to visualize how these allele frequencies are
distributed across the cells. Here we visualize a subset of the variants using 
`FeaturePlot()` and `DoHeatmap()`.

```{r visualize variants, message=FALSE, warning = FALSE}
DefaultAssay(crc) <- "alleles"
alleles.view <- c("12889G>A", "16147C>T", "3244G>A", "9804G>A")
FeaturePlot(
  object = crc,
  features = alleles.view,
  order = TRUE,
  cols = c("grey", "darkred"),
  ncol = 4
) & NoLegend()
```

```{r message=FALSE, warning=FALSE}
DoHeatmap(crc, features = rownames(crc), slot = "data", disp.max = 1) +
  scale_fill_viridis_c()
```

Here, we can see a few interesting patterns for the selected variants. 16147C>T
is present in essentially all epithelial cells and almost exclusively in
epithelial cells (the edge cases where this isn't true are also cases where the
UMAP and clustering don't full agree). It is at 100% allele frequency-- strongly
suggestive of whatever cell of origin of this tumor had the mutation at 100% and
then expanded. We then see at least 3 variants 9728C>T, 1227G>A, 12889G>A that
are mostly present specifically in the epithelial cells that define subclones. 
The variants 824T>C and 3244G>A are found specifically in immune cell
populations, suggesting that these arose from a common hematopoetic progenitor
cell (probably in the bone marrow). 

# TF1 cell line dataset

Next we'll demonstrate a similar workflow to identify cell clones in a different
dataset, this time generated from a TF1 cell line. This dataset contains a bit
more clonal structure, and we'll demonstrate how to identify groups of related
cells (clones) by clustering the allele frequency data.

## Data loading

```{r}
# read the mitochondrial data
tf1.data <- ReadMGATK(dir = "~/data/mito/tf1/tf1-mgatk-data/")

# create a Seurat object
tf1 <- CreateSeuratObject(
  counts = tf1.data$counts,
  meta.data = tf1.data$depth,
  assay = "mito"
)
```

## Identifying variants

```{r}
variants <- IdentifyVariants(tf1, refallele = tf1.data$refallele)
VariantPlot(variants)
```

```{r}
high.conf <- subset(
  variants, subset = n_cells_conf_detected >= 5 &
    strand_correlation >= 0.65 &
    vmr > 0.01
)
```

```{r}
tf1 <- AlleleFreq(tf1, variants = high.conf$variant, assay = "mito")
tf1[["alleles"]]
```

## Identifying clones

```{r}
DefaultAssay(tf1) <- "alleles"
tf1 <- FindClonotypes(tf1)
```

```{r}
table(Idents(tf1))
```

Here we see that the clonal clustering has identified 12 different clones in the
TF1 dataset. We can further visualize these clones using `DoHeatmap()`. The 
`FindClonotypes()` function also performs hierarchical clustering on both the 
clonotypes and the alleles, and sets the factor levels for the clonotypes based
on the hierarchical clustering order, and the order of variable features based
on the hierarchical feature clustering. This allows us to get a decent ordering
of both features and clones automatically:

```{r message=FALSE, warning=FALSE}
DoHeatmap(tf1, features = VariableFeatures(tf1), slot = "data", disp.max = 0.1) +
  scale_fill_viridis_c()
```
<details>
  <summary>**Session Info**</summary>
  
```{r}
sessionInfo()
```

</details>
